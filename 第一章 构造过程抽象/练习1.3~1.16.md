### 练习1.3：
```
#lang racket
;思路：找到a，b的最大值，最小值，然后与c比较

(define a 2)
(define b 5)
(define c 1)
(define (a-b-min a b)
  (cond ((> a b) b)
        ((< a b) a)
        ((= a b) a)))
(define (a-b-max a b)
  (cond ((> a b) a)
        ((< a b) b)
        ((= a b) a)))

(define abmin (a-b-min a b))
(define abmax (a-b-max a b))

(define (res-sum abmin abmax c)
  (cond ((> abmin c) (+ abmin abmax))
        ((< abmax c) (+ abmax c))
        (else (+ abmax c))))


out:
> (res-sum abmin abmax c)
7
```
#### 注：cond中else的用法

### 1.6
```
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))


(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
;参数:一个被开方数,一个猜测值
;(define (sqrt-iter guess x)
;  (if (good-enough? guess x)
;      guess
;      (sqrt-iter (improve guess x)
;                 x)))
;改进猜测的方式:就是求出他与被开方数以上一个猜测的平均值:
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x)(* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))

超内存了
out:
> (sqrt 9)
. Interactions disabled; out of memory
解释：无
```
### 1.8 立方根的牛顿法
```
;参数:一个被开方数,一个猜测值
;(define (sqrt-iter guess x)
;  (if (good-enough? guess x)
;      guess
;      (sqrt-iter (improve guess x)
;                 x)))

(define (cube-iter guess x)
  (if (good-enough? guess x)
      guess
      (cube-iter (improve guess x)
                 x)))
;改进猜测的方式:就是求出他与被开方数以上一个猜测的平均值:
;(define (improve guess x)
;  (average guess (/ x guess)))
;哪个是x，哪个是y
(define (improve guess x)
  (average (* 2 guess) (/ (/ x guess) guess)))


;(define (average x y)
;  (/ (+ x y) 2))

(define (average x y)
  (/ (+ x y) 3))

;(define (good-enough? guess x)
;  (< (abs (- (square guess) x)) 0.001))

(define (good-enough? guess x)
  (< (abs (- (cubear guess) x)) 0.001))

;(define (square x)(* x x))
(define (cubear x)(* x x x))
;(define (sqrt x)
;  (sqrt-iter 1.0 x))

(define (cube x)
  (cube-iter 1.0 x))
  
> (cube 27)
3.0000005410641766
> (cube 125)
5.000000000287929
```
一顿操作。。。

### 1.10
```
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
 ```                
自闭的题目


### 1.11

#### 做错的题目
```
(define (f n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        ((= n 2) 2)
        (else (+(+ (* 3 f(- n 3)) (* 2 f(- n 2)))
                 (* 1 f(- n 1))))))
```
#### AC代码--递归：
```
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* (f (- n 2)) 2)
         (* (f (- n 3)) 3))))
```         
### 迭代：
```
(define (fn4 n)
  (cond ((= 0 n) 0);为了修正初始输入可能是0
        ((= 1 n) 1);为了修正初始输入可能是1
        (else (fn5 0 1 2 n)));初始输入是2的时候,fn5刚好返回2,此处不用修正
)
(define (fn5 a b c counter)  
    (if (< counter 3)
        c
        (fn5 b c (+ (* 3 a) (* 2 b) (* 1 c)) (- counter 1))
    )
)
```
感觉括号下移很规整

### 1.12 帕斯卡三角形，网上的代码
```
(define (p row col)
  (if (or (= col 1)(= row col))
      1
      (+ (p(- row 1)(- col 1))
         (p(- row 1) col))))

```

### 1.15
(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))
  )
)
```
不知道迭代了多少次，看情况吧.

### 1.16 网上代码
```
(define (even? n)
  (= (remainder n 2) 0))

(define (fast_iter_expt n p)
  (cond ((= n 1) p)
        ((even? n) (fast_iter_expt (/ n 2)(* p p)))
        (else (* p (fast_iter_expt (- n 1) p)))))
```

